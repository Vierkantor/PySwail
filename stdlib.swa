// Make syntax definitions less painful

// makes << <name> >> into a submatch
insert(Parser.value, 0, Parser.rule(
	"value",
	[
		Parser.literalMatch("<<"),
		Parser.subMatch("token"),
		Parser.literalMatch(">>")
	],
	function([`parsed, `text], [], `{
		Parser.subMatch(parsed."token".name);
	})
));

// makes '<string>' into a literal match
insert(Parser.value, 0, Parser.rule(
	"value",
	[
		Parser.literalMatch("'"),
		<<token>>,
		Parser.literalMatch("'")
	],
	function([`parsed, `text], [], `{
		Parser.literalMatch(parsed."token");
	})
));

// defines the = operator
set(Parser, `assignment, [
	Parser.rule(
		"assignment",
		[
			<<token>>, '"="', <<expression>>
		],
		function([`parsed, `text], [], `{
			call(`def, [literal(parsed."token"), parsed."expression"]);
		})
	),
	Parser.rule(
		"assignment",
		[
			<<nameSet>>, '"="', <<expression>>
		],
		function([`parsed, `text], [], `{
			def(`result, call(`set, [parsed."nameSet"."getPart", literal(parsed."nameSet"."tokenPart"), parsed."expression"]));
			result;
		})
	)
]);

insert(Parser.expression, 0, Parser.rule(
	"expression",
	[
		<<assignment>>
	],
	function([`parsed, `text], [], `{
		parsed."assignment";
	})
));

// function parameters
Parser.params = [
	Parser.rule(
		"params",
		[
			'")"'
		],
		function([`parsed, `text], [], `{
			[];
		})
	),
	Parser.rule(
		"params",
		[
			<<token>>, '")"'
		],
		function([`parsed, `text], [], `{
			[literal(parsed."token")];
		})
	),
	Parser.rule(
		"params",
		[
			<<token>>, '","', <<params>>
		],
		function([`parsed, `text], [], `{
			insert(parsed."params", 0, literal(parsed."token"));
			parsed."params";
		})
	)
];

// syntax for anonymous function creation
Parser.lambda = [
	Parser.rule(
		"lambda",
		[
			'"function"', '"("', <<params>>, <<block>>
		],
		function([`parsed, `text], [], `{
			call(`function, [parsed."params", [], literal(parsed."block")]);
		})
	)
];

insert(Parser.expression, 0, Parser.rule(
	"expression",
	[
		<<lambda>>
	],
	function([`parsed, `text], [], `{
		parsed."lambda";
	})
));

// syntax for function definition
Parser.functionDef = [Parser.rule(
	"functionDef",
	[
		'"function"', <<token>>, '"("', <<params>>, <<block>>
	],
	function(parsed, text) {
		call(`def, [literal(parsed."token"), call(`function, [parsed."params", [], literal(parsed."block")])]);
	}
)];

insert(Parser.statement, 0, Parser.rule(
	"statement",
	[
		<<functionDef>>
	],
	function(parsed, text) {
		parsed."functionDef";
	}
));

// extended tokens: <<a as b>>
insert(Parser.value, 0, Parser.rule(
	"value",
	[
		''<<'', <<token>>, ''as'', <<literal>>, ''>>''
	],
	function(parsed, text) {
		Parser.subMatch(parsed."token".name, ~ (parsed."literal"));
	}
));

// if statement
Parser.if = [
	Parser.rule(
		"if",
		[
			''if'', ''('', <<expression>>, '')'', <<block>>, ''else'', <<block as `block2>>
		],
		function(parsed, text) {
			call(`if, [parsed."expression", literal(parsed."block"), literal(parsed."block2")]);
		}
	),
	Parser.rule(
		"if",
		[
			''if'', ''('', <<expression>>, '')'', <<block>>
		],
		function(parsed, text) {
			call(`if, [parsed."expression", literal(parsed."block")]);
		}
	)
];

insert(Parser.statement, 0, Parser.rule(
	"statement",
	[
		<<if>>
	],
	function(parsed, text) {
		parsed."if";
	}
));

// syntax for assertion
function assert(condition) {
	if (not(condition)) {
		print("Assertion failed.");
		exit(1);
	}
}

Parser.assert = [Parser.rule(
	"assert",
	[
		''#'', <<expression>>, '';''
	],
	function(parsed, text) {
		call(`assert, [parsed."expression"]);
	}
)];

insert(Parser.statement, 0, Parser.rule(
	"statement",
	[
		<<assert>>
	],
	function(parsed, text) {
		parsed."assert";
	}
));
